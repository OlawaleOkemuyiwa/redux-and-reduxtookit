import { Fragment, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import Cart from './components/Cart/Cart';
import Layout from './components/Layout/Layout';
import Products from './components/Shop/Products';
import { uiActions } from './store/ui-slice';
import Notification from './components/UI/Notification';
import { cartActions } from './store/cart-slice';

let isInitial = true;

function App() {
  const showCart = useSelector(state => state.ui.showCart);
  const cart = useSelector(state => state.cart);
  const notification = useSelector(state => state.ui.notification);

  const dispatch = useDispatch();

  useEffect(() => {    //instead of using this useEffect we could have executed code in the if isInitial block down there cause its only executed on first mount of this component. But this is cleaner

    (async function() {
      try {
        const response = await fetch('https://new-react-http-bdae2-default-rtdb.firebaseio.com/cart.json');
        if (!response.ok) {
          throw new Error('Could not fetch cart data!')
        }

        const cartData = await response.json();
        dispatch(cartActions.replaceCart({
          items: cartData.items || [],
          totalQuantity: cartData.totalQuantity
        }));

      } catch (error) {
        dispatch(uiActions.setNofication({
          title: 'Error!',
          status: 'error',
          message: 'Fetching cart data failed!'
        }))
      }

    })();

  }, [dispatch])


  
  useEffect(() => {

    if (isInitial) {    //to prevent the code in useEffect from executing after the first mount of the component
      isInitial = false;
      return;
    }

    if (cart.cartChanged) {
      (async function() {   //PUT method overrides exisiting data in a repository with a new one (basically we're putting the cart object from our state into a cart repository in firebase) while POST just pushes new data to a repository as a value to a random key generated by firebase (e.g MVsu66YJHidsb: dataPosted )
        try {
          dispatch(uiActions.setNofication({
            title: 'Sending...',
            status: 'pending',
            message: 'Sending cart data'
          }));
    
          const response = await fetch('https://new-react-http-bdae2-default-rtdb.firebaseio.com/cart.json', {
            method: 'PUT',
            body: JSON.stringify({
              items: cart.items,
              totalQuantity: cart.totalQuantity
            })
          })
  
          //using try catch, immediately there is an error somewhere in the try block, its caught in the catch block. So therefore whenever we have an error with putting the cart, the code doesnt even get down here instead the error is caught straight up in the catch block. This throw new Error down here is only if we have no error with putting the cart but for some reason the response is not ok.
          if (!response.ok) {
            throw new Error('Sending cart data failed!')
          }
    
          dispatch(uiActions.setNofication({
            title: 'Successful',
            status: 'success',
            message: 'Sent cart data successfully!'
          }))
  
        } catch (error) {
          dispatch(uiActions.setNofication({
            title: 'Error!',
            status: 'error',
            message: 'Sending cart data failed!'
          }))
        }
      })();
    }
      
  }, [cart, dispatch]);

  return (
    <Fragment>
      {notification && <Notification notification={notification}/>}
      <Layout>
        {showCart && <Cart />}
        <Products />
      </Layout>
    </Fragment>
  );
}

export default App;
